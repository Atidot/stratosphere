{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Stratosphere.Resources
     ( module X
     , Resource (..)
     , resource
     , properties
     , deletionPolicy
     , ResourceProperties (..)
     , DeletionPolicy (..)
     , Resources (..)
     ) where

import Control.Lens hiding ((.=))
import Data.Aeson
import Data.Aeson.Types
import qualified Data.HashMap.Strict as HM
import Data.Maybe (catMaybes)
import qualified Data.Text as T
import GHC.Exts (IsList(..))
import GHC.Generics (Generic)

{{ resourceImports }}
{{ resourcePropImports }}
import Stratosphere.Helpers (maybeField)
import Stratosphere.Values

data ResourceProperties
{{ resourceADT }}
  deriving (Show)

data DeletionPolicy
  = Delete
  | Retain
  | Snapshot
  deriving (Show, Generic, ToJSON, FromJSON)

data Resource =
  Resource
  { resourceName :: T.Text
  , resourceProperties :: ResourceProperties
  , resourceDeletionPolicy :: Maybe DeletionPolicy
  } deriving (Show)

instance ToRef Resource b where
  toRef r = Ref (resourceName r)

resource
  :: T.Text -- ^ Logical name
  -> ResourceProperties
  -> Resource
resource rn rp =
  Resource
  { resourceName = rn
  , resourceProperties = rp
  , resourceDeletionPolicy = Nothing
  }

$(makeFields ''Resource)

instance ToJSON Resource where
  toJSON (Resource _ props dp) =
    object $ resourcePropertiesJSON props ++ catMaybes
    [ maybeField "DeletionPolicy" dp ]

resourcePropertiesJSON :: ResourceProperties -> [Pair]
{{ toJSONFuncs }}

resourceFromJSON :: T.Text -> Object -> Parser Resource
resourceFromJSON n o =
    do type' <- o .: "Type" :: Parser String
       props <- case type' of
{{ fromJSONCases }}
         _ -> fail $ "Unknown resource type: " ++ type'
       dp <- o .:? "DeletionPolicy"
       return $ Resource n props dp


newtype Resources = Resources { unResources :: [Resource] }
                  deriving (Show)

instance IsList Resources where
  type Item Resources = Resource
  fromList = Resources
  toList = unResources

instance ToJSON Resources where
  toJSON (Resources rs) =
    object $ fmap (\r -> resourceName r .= toJSON r) rs

instance FromJSON Resources where
  parseJSON v = do
    objs <- parseJSON v :: Parser (HM.HashMap T.Text Value)
    rs <- sequence [withObject "resource" (resourceFromJSON n) obj |
                    (n, obj) <- HM.toList objs]
    return $ Resources rs